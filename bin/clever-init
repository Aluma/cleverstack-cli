#!/usr/bin/env node

GLOBAL.bar = require( 'node-status' );
GLOBAL.console = process.stdout = process.stderr = bar.console();
GLOBAL.lib = require( (require('path')).join( __dirname, '..', 'lib' ) );

var path            = require( 'path' )
  , fs              = require( 'fs' )
  , mkdirp          = require( 'mkdirp' )
  , rimraf          = require( 'rimraf' )
  , async           = require( 'async' )
  , exec            = require( 'child_process' ).exec
  , Promise         = require( 'bluebird' )
  , seedRelatedArgs = [ 'frontend', 'backend' ]
  , projectFolder   = null
  , singleSeed      = true
  , seedsToInstall  = [];

/**  CLI Progress Bar & Info
================================*/
GLOBAL.progress = bar.addItem( 'Installation Progress', {
  color: 'green',
  type: [ 'bar','percentage' ],
  max: 10,
  precision: 0
});
GLOBAL.installing = bar.addItem( 'Installing', {
  color: 'cyan',
  type: 'text',
  text: 'Loading...'
});
GLOBAL.running = bar.addItem( 'Task Running', {
  color: 'orange',
  type: 'text',
  text: 'Loading...'
});

/**  CLI Program
================================*/
GLOBAL.program = require( 'commander' );

// Define CleverStack-CLI
program
  .option( '-f, --force', 'delete existing projects in your current directory ' + process.cwd() )
  .option( '-v, --verbose', 'verbose output useful for debugging' )
  .option( '-A, --allow-root', 'allow root for bower' )
  .option( '-S, --skip-protractor', 'skips installing protractor (Frontend only)' )
  .version( lib.pkg.version );

// Define the project command
program
  .command( '<project>' )
  .description( 'creates a new project named <project>' );

// Define the help that will be displayed when using --help
program.on( '--help', function() {
  console.log( '  Examples:' );
  console.log( '' );
  console.log( '    clever init my-project                      install the backend and frontend' );
  console.log( '    clever init my-project clever-auth          with the clever-auth module' );
  console.log( '    clever init my-project backend frontend     verbose way of running "clever init my-project"' );
  console.log( '    clever init my-project frontend             only install the frontend' );
  console.log( '    clever init my-project backend clever-auth  install the clever-auth module after installing the backend and frontend seeds' );
  console.log( '' );
  console.log( '    Installing specific versions:' );
  console.log( '' );
  console.log( '      clever init my-project backend@<version>' );
  console.log( '      clever init my-project clever-auth@<version>' );
  console.log( '' );
});

// Parse CLI arguments
program.parse( process.argv );

// Assign CLI arguments
var project = program.args[ 0 ]
  , args    = program.args.slice( 1 )
  , installFrontend = args.indexOf( 'frontend' ) !== -1
  , installBackend = args.indexOf( 'backend' ) !== -1;

// Display help if we have no project
if ( !project || project.toString().trim() === "" ) {
  program.help(); // this calls process.exit()
} else {

  // Define the directory where the project needs to be
  projectFolder = path.join( process.cwd(), project );
  projectFolderExists = fs.existsSync( projectFolder );
}

// Tell promise we want long stack traces for easier debugging
Promise.longStackTraces();

/**
 * Writes a local.json file within projectDir
 * with the basic ORM values
 *
 * @todo we need to change this over to a template
 * @param  {String} projectDir
 * @return {Promise}
 * @api private
 */
function writeLocalJSON( projectDir ) {
  var deferred = Promise.defer()
    , localJSONFile = require( path.join( projectDir, 'config', 'local.example.json' ) );

  lib.utils.info( [ '  Creating local configuration file config/local.json', '...' ].join( '' ) );
  running.text = 'Creating configs...';

  if (localJSONFile !== null) {
    localJSONFile['clever-orm'] = localJSONFile['clever-orm'] || {};
    localJSONFile['clever-orm'].db = localJSONFile['clever-orm'].db || {};

    [ 'username', 'password', 'database' ].forEach( function ( key ) {
      localJSONFile['clever-orm'].db[key] = localJSONFile['clever-orm'].db[key] || '';
    } );

    localJSONFile['clever-orm'].db.options = localJSONFile['clever-orm'].db.options || {};

    [ 'dialect', 'host', 'port' ].forEach( function ( key ) {
      localJSONFile['clever-orm'].db.options[key] = localJSONFile['clever-orm'].db.options[key] || '';
    } );
  }

  fs.writeFile( path.join( projectDir, 'config', 'local.json' ), JSON.stringify( localJSONFile, null, 2 ), function ( err ) {
    if (!!err) {
      return deferred.reject( err );
    }

    deferred.resolve();
  });

  return deferred.promise;
}

function installNPMPackages( projectDir ) {
  var deferred = Promise.defer();
  
  lib.utils.info( [ '  Installing NPM modules...' ].join( '' ) );
  running.text = 'Installing NPM modules...';
  var proc = exec( 'npm install', { cwd: projectDir }, function( err, stdout, stderr ) {
    if ( !!err ) {
      lib.utils.fail( err );
    } else {
      deferred.resolve();
    }
  });

  // Pipe the output of exec if verbose has been specified
  if ( program.verbose ) {
    proc.stdout.pipe( process.stdout );
    proc.stderr.pipe( process.stdout );
  }

  return deferred.promise;
}

/**
 * Installs the node-seed as 'backend' and then writes
 * a local JSON file through writeLocalJSON()
 *
 * @return {Promise}
 * @api private
 */
function setupBackend() {
  var deferred   = Promise.defer()
    , projectDir = ( singleSeed === true )
        ? projectFolder
        : path.join( projectFolder, 'backend' );

  lib.utils.info( [ 'Installing Backend...' ].join( '' ) );
  running.text = 'Installing Backend...';

  if ( projectDir !== projectFolder ) {
    lib.utils.info( [ '  Installation path is ', projectDir, '...' ].join( '' ) );
  }

  mkdirp( projectDir, function backendProjectDirReady( err ) {
    var pkg = args.indexOf( 'backend' ) !== -1
          ? args[ args.indexOf( 'backend' ) ].split( '@' )
          : false
      , csPackage = {
          owner: 'CleverStack',
          name: 'node-seed' + ( pkg && typeof pkg[ 1 ] !== "undefined" ? '@' + pkg[ 1 ] : '' )
        };
   
    if ( !!err ) {
      return deferred.reject( err );
    }

    lib.utils.info( [ '  Downloading and extracting ', csPackage.name, '...' ].join( '' ) );
    running.text = 'Downloading and extracting...';
    lib.packages
      .get( csPackage, projectDir )
      .then(function() {
        progress.inc();
        return writeLocalJSON( projectDir );
      })
      .then(function() {
        progress.inc();
        return installNPMPackages( projectDir );
      })
      .then(function() {
        progress.inc();
        lib.utils.info( [ '  Installing bundledDependencies...' ].join( '' ) );
        running.text = 'Installing bundledDependencies...';
        return lib.util.dependencies.installBundleDeps( projectDir );
      })
      .then(function() {
        progress.inc();

        lib.utils.success( '  Backend installation has completed successfully!\n' );
        deferred.resolve();
      })
      .catch( deferred.reject );
  });

  return deferred.promise;
}

/**
 * Installs angular-seed as 'frontend'
 *
 * @return {Promise}
 * @api private
 */
function setupFrontend( ) {
  var deferred   = Promise.defer()
    , projectDir = ( singleSeed === true )
        ? projectFolder
        : path.join( projectFolder, 'frontend' );

  lib.utils.info( [ 'Installing Frontend...' ].join( '' ) );
  running.text = 'Installing...';

  if ( projectDir !== projectFolder ) {
    lib.utils.info( [ '  Installation path is ', projectDir, '...' ].join( '' ) );
  }

  mkdirp( path.resolve( projectDir ), function( err ) {
    var pkg = args.indexOf( 'frontend' ) !== -1
          ? args[ args.indexOf( 'frontend' ) ].split( '@' )
          : false
      , csPackage = {
          owner: 'CleverStack',
          name: 'angular-seed' + ( pkg && typeof pkg[ 1 ] !== "undefined" ? '@' + pkg[ 1 ] : '' )
        };

    if ( !!err ) {
      return deferred.reject( err );
    }

    lib.utils.info( [ '  Downloading and extracting ', csPackage.name, '...' ].join( '' ) );
    running.text = 'Downloading and extracting...';
    lib.packages
      .get( csPackage, projectDir )
      .then(function() {
        progress.inc();
        return installNPMPackages( projectDir );
      })
      .then(function() {
        progress.inc();
        lib.utils.info( [ '  Installing bundled modules...' ].join( '' ) );
        running.text = 'Installing bundled modules...';

        return new Promise(function( resolve, reject ) {
          var modulesFolder = path.resolve( path.join( projectDir, 'app', 'modules' ) )
            , modules = [];

          if (fs.existsSync( modulesFolder )) {
            modules = fs.readdirSync( modulesFolder );
            var keep = modules.indexOf( '.gitkeep' );
            if (keep > -1) {
              modules.splice( keep, 1 );
            }
          }

          async.each(
            modules,
            function( m, callback ) {
              var installOptions = { moduleDir: modulesFolder, modulePath: '' }
                , module = path.resolve( path.join( modulesFolder, m ) );

              lib.project
                .installModule( installOptions, module )
                .then(function() {
                  callback();
                })
                .catch(function( err ) {
                  callback( err );
                });
            },
            function( err ) {
              if ( !err ) {
                resolve();
              } else {
                reject( err );
              }
            }
          );
        });
      })
      .then(function() {
        progress.inc();
        return installBowerComponents( projectDir );
      })
      .then(function() {
        progress.inc();
        lib.utils.info( [ '  Building frontend...' ].join( '' ) );
        running.text = 'Building...';

        return new Promise(function( resolve, reject ) {
          var proc = exec( 'grunt bootstrap build', { cwd: projectDir }, function ( err ) {
            if ( !err ) {
              lib.utils.success( [ '  Frontend installation has completed successfully.' ].join( '' ) );
              resolve();
            } else {
              reject( err );
            }
          });

          // Pipe the output of exec if verbose has been specified
          if ( program.verbose ) {
            proc.stdout.pipe( process.stdout );
            proc.stderr.pipe( process.stdout );
          }
        });
      })
      .then(function() {
        progress.inc();

        return new Promise( function( resolve, reject ) {
          if ( program.skipProtractor === true ) {
            progress.inc(2);
            lib.utils.warn( '  Skipping installation of protractor!\n' );
            return resolve();
          } else {
            lib.utils.warn( [ '  Installing protractor...' ].join( '' ) );
            running.text = 'Installing protractor (this might take awhile)...';
          }

          var proc = exec( 'npm run-script setup-protractor', { cwd: projectDir }, function( err ) {
            if ( !err ) {
              lib.utils.success( [ '  Protractor successfully installed...\n' ].join( '' ) );
              progress.inc(2);
              resolve();
            } else {
              reject( err );
            }
          });

          // Pipe the output of exec if verbose has been specified
          if ( program.verbose ) {
            proc.stdout.pipe( process.stdout );
            proc.stderr.pipe( process.stdout );
          }
        });
      })
      .then(function() {
        deferred.resolve();
      })
      .catch(function( err ) {
        deferred.reject( err );
      });
  });

  return deferred.promise;
}

function installBowerComponents( projectDir ) {
  var deferred = Promise.defer()
    , bowerPath = path.resolve( path.join( projectDir, 'bower.json' ) );

  running.text = 'Installing bower components...';
  lib.utils.info( [ '  Installing bower components...' ].join( '' ) );

  fs.exists( bowerPath, function( exists ) {
    if ( !exists ) {
      return deferred.reject( 'Bower not found' );
    }

    lib.project
      .installBowerComponents({
        moduleDir: projectDir,
        modulePath: 'app/modules' // todo: Call locations( ) after population
      })
      .then(function() {
        deferred.resolve();
      })
      .catch(function( err ) {
        deferred.reject( err );
      });
  });

  return deferred.promise;
}

async.waterfall(
  [
    function startBar( callback ) {
      bar.start({
        interval: 50
      });
      setTimeout( callback, 1500 );
    },

    function start( callback ) {
      lib.utils.info( 'Preparing...' );
      installing.text = 'Preparing';
      running.text = 'Preparing...'

      if ( program.verbose ) {
        running.text = 'Outputting debugging information...';

        lib.utils.info( '-----------------------------' );
        lib.utils.info( 'args             = ' + JSON.stringify( args ) );
        lib.utils.info( '--force          = ' + program.force );
        lib.utils.info( 'project          = "' + project + '"' );
        lib.utils.info( 'projectFolder    = "' + projectFolder+ '"' );
        lib.utils.info( 'singleSeed       = ' + singleSeed );
        lib.utils.info( 'installFrontend  = ' + installFrontend );
        lib.utils.info( 'installBackend   = ' + installBackend );
        lib.utils.info( '-----------------------------' );
      }

      setTimeout( callback, 100 );
    },

    function forceDeleteProjectFolder( callback ) {
      running.text = 'Checking if project alredy exists...';

      if ( projectFolderExists && program.force ) {
        lib.utils.warn( [ '  Deleting the installation path for', project, 'before we begin installing!' ].join( ' ' ) );

        running.text = 'Deleting old project...';
        rimraf( projectFolder, function( err ) {
          if ( !err ) {
            projectFolderExists = false;
            progress.inc();
            callback( null );
          } else {
            callback( [ 'Unable to delete the', project, ' folder in', process.cwd(), 'because of', err ].join( ' ' ) );
          }
        });
      } else {
        progress.inc();
        callback( null );
      }
    },

    function createProjectFolder( callback ) {
      running.text = 'Creating project installation path...';

      if ( !projectFolderExists ) {
        lib.utils.info( [ '  Creating installation path', projectFolder + '...' ].join( ' ' ) );

        mkdirp( projectFolder, function( err ) {
          progress.inc();
          callback( !err ? null : [ 'Cannot create', project, 'folder in', process.cwd(), 'because of', err ].join( ' ' ) );
        });
      } else {
        callback( [ project, 'folder already exists at', process.cwd() + ',', 'to force/overwrite (delete)', project, ', use --force' ].join( ' ' ) );
      }
    },

    function findTargets( callback ) {
      lib.utils.info( [ '  Finding seeds to target for installation...' ].join( ' ' ) );
      running.text = 'Finding seeds to target for installation...';

      if ( args.length < 1 || ( !installFrontend && !installBackend ) || ( installFrontend && installBackend ) ) {

        singleSeed = false;
        seedsToInstall.push( { name: 'Backend', install: setupBackend } );
        seedsToInstall.push( { name: 'Frontend', install: setupFrontend } );
        progress.max = 16;

      } else if ( installFrontend ) {

        progress.max = 12;
        seedsToInstall.push( { name: 'Frontend', install: setupFrontend }  );

      } else if ( installBackend ) {

        progress.max = 9;
        seedsToInstall.push( { name: 'Backend', install: setupBackend }  );
      }

      callback( null );
    },

    function runActions( callback ) {

      lib.utils.success( [ '  Starting installation...\n' ].join( ' ' ) );
      running.text = 'Starting installation...';

      async.forEachSeries(
        seedsToInstall,
        function runAction( seed, cb ) {
          installing.text = seed.name;
          running.text = [ '  Preparing to install', seed.name + '...' ].join( ' ' );

          seed.install()
            .then(function() {
              installing.text = 'Seeds successfully installed...';
              progress.inc();
              cb( null );
            })
            .catch( cb );
        },
        callback
      );
    },

    function removeSeedRelatedArgs( callback ) {
      installing.text = 'Modules';
      running.text = 'Cleaning CLI arguments to find modules...';

      seedRelatedArgs.forEach( function( filter ) {
        var index = args.indexOf( filter );
        if ( index > -1 ) {
          args.splice( index, 1 );
        }
      });
      callback( null );
    },

    function installModules( callback ) {
      running.text = 'Checking for modules to install...';

      if ( args.length < 1 ) {
        running.text = 'No modules need to be installed, skipping...';
        process.nextTick(function( ) {
          progress.inc();
          callback( null );
        });
      } else {
        lib.utils.info( [ 'Installing Modules...' ].join( ' ' ) );
        running.text = 'Installing...';

        lib.project
          .setupModules( { moduleDir: projectFolder }, args )
          .then(function() {
            progress.inc();
            callback( null );
          })
          .catch( callback );
      }
    },

    // function setupPackagesNew( callback ) {
    //   installing.text = 'Frontend Bower Packages';
    //   running.text = 'Checking necessary packages...';

    //   if ( installFrontend ) {
    //     lib.utils.info( 'Installing frontend bower packages...' );
        
    //     setupPackages()
    //       .then(function() {
    //         installing.text = 'Finished Installation...';
    //         progress.inc();
    //         callback( null );
    //       })
    //       .catch( callback );
    //   } else {
    //     progress.inc();
    //     callback( null );
    //   }
    // }

  ],
  function initComplete( err ) {
    if ( !err ) {
      progress.inc();
      running.text = 'Installation completed';
      installing.text = 'Done';
      lib.utils.success( '\nProject ' + project + ' has been created in ' + projectFolder + '\n' );
      process.exit( 0 );
    } else {
      lib.utils.fail( err )
    }
  }
);
