#!/usr/bin/env node

var path            = require( 'path' )
  , fs              = require( 'fs' )
  , mkdirp          = require( 'mkdirp' )
  , rimraf          = require( 'rimraf' )
  , async           = require( 'async' )
  , exec            = require( 'child_process' ).exec
  , Promise         = require( 'bluebird' )
  , seedRelatedArgs = [ 'frontend', 'backend' ]
  , projectFolder   = null
  , singleSeed      = true
  , seedsToInstall  = [];

/**  Bootstrap CLI bar & libs
================================*/
GLOBAL.bar = require( 'node-status' );
GLOBAL.progress = bar.addItem( 'Installation Progress', {
  color: 'green',
  type: [ 'bar','percentage' ],
  max: 10,
  precision: 0
});
GLOBAL.installing = bar.addItem( 'Installing', {
  color: 'cyan',
  type: 'text',
  text: 'Loading...'
});
GLOBAL.running = bar.addItem( 'Task Running', {
  color: 'orange',
  type: 'text',
  text: 'Loading...'
});
GLOBAL.console = process.stdout = process.stderr = bar.console();
GLOBAL.lib = require( path.join( __dirname, '..', 'lib' ) )

/**  CLI Program
================================*/
GLOBAL.program = require( 'commander' );

// Define CleverStack-CLI
program
  .option( '-f, --force', 'delete/overwrite existing projects in your current directory ' + process.cwd() )
  .option( '-v, --verbose', 'verbose output useful for debugging' )
  .option( '-A, --allow-root', 'allow root for bower' )
  .option( '-S, --skip-protractor', 'skips installing protractor (Frontend only)' )
  .version( lib.pkg.version );

// Define the project command
program
  .command( '<project>' )
  .description( 'creates a new project named <project>' );

// Define the help that will be displayed when using --help
program.on( '--help', function() {
  console.log( '  Examples:' );
  console.log( '' );
  console.log( '    clever init my-project                      install the backend and frontend' );
  console.log( '    clever init my-project clever-auth          with the clever-auth module' );
  console.log( '    clever init my-project backend frontend     verbose way of running "clever init my-project"' );
  console.log( '    clever init my-project frontend             only install the frontend' );
  console.log( '    clever init my-project backend clever-auth  install the clever-auth module after installing the backend and frontend seeds' );
  console.log( '' );
  console.log( '    Installing specific versions:' );
  console.log( '' );
  console.log( '      clever init my-project backend@<version>' );
  console.log( '      clever init my-project clever-auth@<version>' );
  console.log( '' );
});

// Parse CLI arguments
program.parse( process.argv );

// Assign CLI arguments
var project = program.args[ 0 ]
  , args    = program.args.slice( 1 )
  , installFrontend = args.indexOf( 'frontend' ) !== -1
  , installBackend = args.indexOf( 'backend' ) !== -1;

// Display help if we have no project
if ( !project || project.toString().trim() === "" ) {
  program.help(); // this calls process.exit()
} else {

  // Define the directory where the project needs to be
  projectFolder = path.join( process.cwd(), project );
  projectFolderExists = fs.existsSync( projectFolder );
}

// Tell promise we want long stack traces for easier debugging
Promise.longStackTraces();

/**
 * Writes a local.json file within projectDir
 * with the basic ORM values
 *
 * @todo we need to change this over to a template
 * @param  {String} projectDir
 * @return {Promise}
 * @api private
 */

function writeLocalJSON( projectDir ) {
  var deferred = Promise.defer()
    , localJSONFile = require( path.join( projectDir, 'config', 'local.example.json' ) );

  lib.utils.info( [ '  Creating local configuration file config/local.json', '...' ].join( '' ) );
  running.text = 'Creating configs...';

  if (localJSONFile !== null) {
    localJSONFile['clever-orm'] = localJSONFile['clever-orm'] || {};
    localJSONFile['clever-orm'].db = localJSONFile['clever-orm'].db || {};

    [ 'username', 'password', 'database' ].forEach( function ( key ) {
      localJSONFile['clever-orm'].db[key] = localJSONFile['clever-orm'].db[key] || '';
    } );

    localJSONFile['clever-orm'].db.options = localJSONFile['clever-orm'].db.options || {};

    [ 'dialect', 'host', 'port' ].forEach( function ( key ) {
      localJSONFile['clever-orm'].db.options[key] = localJSONFile['clever-orm'].db.options[key] || '';
    } );
  }

  fs.writeFile( path.join( projectDir, 'config', 'local.json' ), JSON.stringify( localJSONFile, null, 2 ), function ( err ) {
    if (!!err) {
      return deferred.reject( err );
    }

    deferred.resolve();
  });

  return deferred.promise;
}

function installNPMPackages( projectDir ) {
  var deferred = Promise.defer();
  
  lib.utils.info( [ '  Installing NPM modules...' ].join( '' ) );
  running.text = 'Installing NPM modules...';
  var proc = exec( 'npm install', { cwd: projectDir }, function( err, stdout, stderr ) {
    if ( !!err ) {
      lib.utils.fail( err );
    } else {
      deferred.resolve();
    }
  });

  // Pipe the output of exec if verbose has been specified
  if ( program.verbose ) {
    proc.stdout.pipe( process.stdout );
    proc.stderr.pipe( process.stdout );
  }

  return deferred.promise;
}

/**
 * Installs the node-seed as 'backend' and then writes
 * a local JSON file through writeLocalJSON()
 *
 * @return {Promise}
 * @api private
 */
function setupBackend() {
  var deferred   = Promise.defer()
    , projectDir = ( singleSeed === true )
        ? projectFolder
        : path.join( projectFolder, 'backend' );

  lib.utils.info( [ 'Installing Backend...' ].join( '' ) );
  running.text = 'Installing Backend...';

  if ( projectDir !== projectFolder ) {
    lib.utils.info( [ '  Installation path is ', projectDir, '...' ].join( '' ) );
  }

  mkdirp( projectDir, function backendProjectDirReady( err ) {
    var pkg = args.indexOf( 'backend' ) !== -1
          ? args[ args.indexOf( 'backend' ) ].split( '@' )
          : false
      , csPackage = {
          owner: 'CleverStack',
          name: 'node-seed' + ( pkg && typeof pkg[ 1 ] !== "undefined" ? '@' + pkg[ 1 ] : '' )
        };
   
    if ( !!err ) {
      return deferred.reject( err );
    }

    lib.utils.info( [ '  Downloading and extracting ', csPackage.name, '...' ].join( '' ) );
    running.text = 'Downloading and extracting...';
    lib.packages
      .get( csPackage, projectDir )
      .then( function() {
        progress.inc();
        return writeLocalJSON( projectDir );
      })
      .then( function() {
        progress.inc();
        return installNPMPackages( projectDir );
      })
      .then( function() {
        progress.inc();
        lib.utils.info( [ '  Installing bundledDependencies...' ].join( '' ) );
        running.text = 'Installing bundledDependencies...';
        return lib.util.dependencies.installBundleDeps( projectDir );
      } )
      .then( function() {
        progress.inc();

        lib.utils.success( '  Backend installation has completed successfully!\n' );
        deferred.resolve();
      })
      .catch( deferred.reject );
  });

  return deferred.promise;
}

/**
 * Installs angular-seed as 'frontend'
 *
 * @return {Promise}
 * @api private
 */

function setupFrontend( ) {
  var def         = Promise.defer( )
    , projectDir  = path.join( projectFolder, 'frontend' );

  mkdirp( path.resolve( projectDir ), function ( err ) {
    if (!!err) {
      return def.reject( err );
    }

    var pkg = args[ args.indexOf( 'frontend' ) ].split( '@' );

    lib.packages.get( { name: 'angular-seed' + ( typeof pkg[ 1 ] !== "undefined" ? '@' + pkg[ 1 ] : '' ), owner: 'CleverStack' }, projectDir )
    .then( function ( ) {
      var res = Promise.defer( );

      lib.utils.info( 'Installing NPM packages for ' + projectDir );
      var proc = spawn( 'npm', [ 'install' ], { cwd: projectDir } )
        , err = '';

      proc.stderr.on('data', function ( data ) {
        err += data + '';
      } );

      proc.on( 'close', function ( code ) {
        if (code !== 0) {
          return res.reject( err );
        }

        res.resolve( );
      } );

      return res.promise;
    } )
    .then( function ( ) {
      progress.inc( );
      def.resolve( );
    }, function ( err ) {
      def.reject( err );
    } );
  } );

  return def.promise;
}

/**
 * Installs Bower and NPM (including modules within the seeds) packages
 *
 * @return {Promise}
 * @api private
 */

function setupPackages( ) {
  var def = Promise.defer( );

  async.each( fs.readdirSync( projectFolder ), function ( p, fn ) {
    var _path = path.resolve( path.join( projectFolder, p ) );

    lib.utils.success( 'Finished installing NPM packages for ' + _path );

    var modulesFolder = path.resolve( path.join( projectFolder, p, 'modules' ) )
      , modules = [ ];

    if (fs.existsSync( modulesFolder )) {
      modules = fs.readdirSync( modulesFolder );
      var keep = modules.indexOf( '.gitkeep' );
      if (keep > -1) {
        modules.splice( keep, 1 );
      }

      lib.utils.warn( 'Installing module NPMs for ' + _path );
    }

    async.each( modules, function ( m, next ) {
      lib.project.installModule( {
        moduleDir: modulesFolder,
        modulePath: ''
      }, path.resolve( path.join( modulesFolder, m ) ), program )
      .then( function ( ) {
        next( );
      } )
      .catch( function ( err ) {
        next( err );
      } );
    },
    function ( err ) {
      if (!!err) {
        return fn( err );
      }

      if (modules.length > 0) {
        lib.utils.success( 'Finished installing module NPMs' );
      }

      var bowerPath = path.resolve( path.join( projectFolder, p, 'bower.json' ) );

      // backend folder?
      if (!fs.existsSync( bowerPath ) ) {
        progress.inc( );
        return fn( );
      }

      lib.project.installBowerComponents( {
        moduleDir: _path,
        modulePath: 'app/modules' // todo: Call locations( ) after population
      }, program )
      .then( function ( ) {
        progress.inc( );
        lib.utils.success( 'Finished installing bower packages.' );

        //todo: Separate this into it's own function
        lib.utils.info( 'Building frontend' );

        exec( 'grunt bootstrap build', { cwd: _path }, function ( err ) {
          if (!!err) {
            return fn( err );
          }

          lib.utils.success( 'Finished building frontend' );

          if (program.skipProtractor === true) {
            progress.inc( );
            progress.inc( );
            return fn( );
          }

          progress.inc( );

          lib.utils.info( 'Installing protractor for frontend...' );
          var _tick = 0
            , procProgress = [
              'Downloading specific Selenium Server',
              'Downloading OS specific Chromedriver',
              'Downloading OS specific Phantomjs'
            ];

          var procBar = bar.addItem( procProgress[ _tick ], {
            type: [ 'bar','percentage' ],
            max: 100,
            precision: 0
          } );

          var proProc = spawn( 'npm', [ 'run-script', 'setup-protractor' ], { cwd: _path } )
            , procErr = '';

          proProc.stderr.on( 'data', function ( data ) {
            procErr += data + '';
          } );

          proProc.stdout.on( 'data', function ( data ) {
            var d = data + ''
              , match = d.match(/\d{1,2}%/);

            if (match !== null) {
              var perc = parseInt( match[ 0 ].replace( '%', '' ), 10 );
              if (perc > procBar.count || perc >= 99) {
                procBar.inc( );
                if (procBar.count >= 100 && _tick < 2) {
                  _tick++;
                  procBar.name  = procProgress[ _tick ];
                  procBar.count = 0;
                }
              }
            }
          } );

          proProc.on( 'close', function ( code ) {
            if (code !== 0) {
              return fn( err );
            }

            // two because it's a big chunk of the %
            progress.inc( );
            progress.inc( );
            fn( );
          } );
        } );
      }, fn );
    } );
  },
  function ( err ) {
    if (!!err) {
      return def.reject( err );
    }

    def.resolve( );
  } );

  return def.promise;
}

async.waterfall(
  [
    function startBar( callback ) {
      bar.start({
        interval: 50
      });
      setTimeout( callback, 1500 );
    },

    function start( callback ) {
      lib.utils.info( 'Preparing...' );
      installing.text = 'Preparing';

      if ( program.verbose ) {
        running.text = 'Outputting debugging information...';

        lib.utils.info( '-----------------------------' );
        lib.utils.info( 'args             = ' + JSON.stringify( args ) );
        lib.utils.info( '--force          = ' + program.force );
        lib.utils.info( 'project          = "' + project + '"' );
        lib.utils.info( 'projectFolder    = "' + projectFolder+ '"' );
        lib.utils.info( 'singleSeed       = ' + singleSeed );
        lib.utils.info( 'installFrontend  = ' + installFrontend );
        lib.utils.info( 'installBackend   = ' + installBackend );
        lib.utils.info( '-----------------------------' );
      }
      callback( null );
    },

    function forceDeleteProjectFolder( callback ) {
      running.text = 'Checking if project alredy exists...';

      if ( projectFolderExists && program.force ) {
        lib.utils.warn( [ '  Deleting the installation path for', project, 'before we begin installing!' ].join( ' ' ) );

        running.text = 'Deleting old project...';
        rimraf( projectFolder, function( err ) {
          if ( !err ) {
            projectFolderExists = false;
            progress.inc();
            callback( null );
          } else {
            callback( [ 'Unable to delete the', project, ' folder in', process.cwd(), 'because of', err ].join( ' ' ) );
          }
        });
      } else {
        progress.inc();
        callback( null );
      }
    },

    function createProjectFolder( callback ) {
      running.text = 'Creating project installation path...';

      if ( !projectFolderExists ) {
        lib.utils.info( [ '  Creating installation path', projectFolder + '...' ].join( ' ' ) );

        mkdirp( projectFolder, function( err ) {
          progress.inc();
          callback( !err ? null : [ 'Cannot create', project, 'folder in', process.cwd(), 'because of', err ].join( ' ' ) );
        });
      } else {
        callback( [ project, 'folder already exists at', process.cwd() + ',', 'to force/overwrite (delete)', project, ', use --force' ].join( ' ' ) );
      }
    },

    function findTargets( callback ) {
      lib.utils.info( [ '  Finding seeds to target for installation...' ].join( ' ' ) );
      running.text = 'Finding seeds to target for installation...';

      if ( args.length < 1 || ( !installFrontend && !installBackend ) || ( installFrontend && installBackend ) ) {

        singleSeed = false;
        seedsToInstall.push( { name: 'Backend', install: setupBackend } );
        seedsToInstall.push( { name: 'Frontend', install: setupFrontend }  );
        progress.max = program.skipProtractor === true ? 9 : 10;

      } else if ( installFrontend ) {

        progress.max = program.skipProtractor === true ? 4 : 5;
        seedsToInstall.push( { name: 'Frontend', install: setupFrontend }  );

      } else if ( installBackend ) {

        seedsToInstall.push( { name: 'Backend', install: setupBackend }  );
      }

      callback( null );
    },

    function runActions( callback ) {

      lib.utils.success( [ '  Starting installation...\n' ].join( ' ' ) );
      running.text = 'Starting installation...';

      async.forEach(
        seedsToInstall,
        function runAction( seed, cb ) {
          installing.text = seed.name;
          running.text = [ '  Preparing to install', seed.name + '...' ].join( ' ' );

          seed.install()
            .then(function() {
              installing.text = 'Seeds successfully installed...';
              progress.inc();
              cb( null );
            })
            .catch( cb );
        },
        callback
      );
    },

    function removeSeedRelatedArgs( callback ) {
      installing.text = 'Modules';
      running.text = 'Cleaning CLI arguments to find modules...';

      seedRelatedArgs.forEach( function( filter ) {
        var index = args.indexOf( filter );
        if ( index > -1 ) {
          args.splice( index, 1 );
        }
      });
      callback( null );
    },

    function installModules( callback ) {
      running.text = 'Checking for modules to install...';

      if ( args.length < 1 ) {
        running.text = 'No modules need to be installed, skipping...';
        process.nextTick(function( ) {
          progress.inc();
          callback( null );
        });
      } else {
        lib.utils.info( [ 'Installing Modules...' ].join( ' ' ) );
        running.text = 'Installing...';

        lib.project
          .setupModules( { moduleDir: projectFolder }, args )
          .then(function() {
            progress.inc();
            callback( null );
          })
          .catch( callback );
      }
    },

    function setupPackagesNew( callback ) {
      installing.text = 'Frontend Bower Packages';
      running.text = 'Checking necessary packages...';

      if ( installFrontend ) {
        lib.utils.info( 'Installing frontend bower packages...' );
        
        setupPackages()
          .then(function() {
            installing.text = 'Finished Installation...';
            progress.inc();
            callback( null );
          })
          .catch( callback );
      } else {
        progress.inc();
        callback( null );
      }
    }

  ],
  function initComplete( err ) {
    if ( !err ) {
      progress.inc();
      running.text = 'Installation completed';
      installing.text = 'Done';
      lib.utils.success( '\nProject ' + project + ' has been created in ' + projectFolder + '\n' );
      process.exit( 0 );
    } else {
      lib.utils.fail( err )
    }
  }
);
